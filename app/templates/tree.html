<!DOCTYPE html>
<html>
<head>
    <title>Enhanced Function Segment Tree Viewer</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            line-height: 1.6;
            background-color: #f5f5f5;
        }
        header {
            background-color: #333;
            color: white;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.12);
            min-height: calc(100vh - 100px);
        }
        .repo-info {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #eee;
        }
        .repo-title {
            font-size: 1.5em;
            font-weight: bold;
        }
        .repo-url {
            color: #666;
            margin-top: 5px;
            word-break: break-all;
        }
        .tree-container {
            display: flex;
        }
        .tree-nav {
            width: 25%;
            border-right: 1px solid #eee;
            padding-right: 20px;
            overflow-y: auto;
            max-height: 800px;
        }
        .function-preview {
            width: 75%;
            padding-left: 20px;
            display: flex;
            flex-direction: column;
        }
        .upper-panel {
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            background-color: #f8f9fa;
            max-height: 300px;
            overflow-y: auto;
        }
        .lower-panel {
            flex-grow: 1;
            overflow-y: auto;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            max-height: 500px;
        }
        .node {
            margin-left: 20px;
            position: relative;
        }
        .node-root {
            margin-left: 0;
        }
        .caret {
            cursor: pointer;
            user-select: none;
            position: relative;
            padding: 5px 0;
            display: block;
        }
        .caret::before {
            content: "⊞";
            color: #333;
            display: inline-block;
            margin-right: 6px;
        }
        .caret-down::before {
            content: "⊟";
        }
        .nested {
            display: none;
        }
        .active {
            display: block;
        }
        pre {
            background-color: #f9f9f9;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #ddd;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        code {
            font-family: Consolas, Monaco, 'Andale Mono', monospace;
            font-size: 14px;
        }
        .breadcrumb {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }
        .breadcrumb a {
            color: #333;
            text-decoration: none;
        }
        .breadcrumb a:hover {
            text-decoration: underline;
        }
        .active-node {
            background-color: #e0f7fa;
            border-radius: 3px;
        }
        .code-type {
            color: #666;
            font-size: 0.8em;
            margin-bottom: 5px;
        }
        .function-name {
            font-weight: bold;
        }
        .file-path {
            font-size: 0.9em;
            color: #666;
            margin-top: 5px;
        }
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(0, 0, 0, 0.1);
            border-radius: 50%;
            border-top-color: #09f;
            animation: spin 1s ease-in-out infinite;
            margin: 0 auto;
        }
        .function-details {
            margin-bottom: 20px;
        }
        .segment {
            margin-bottom: 15px;
            padding: 10px;
            border-radius: 4px;
        }
        .segment-code {
            background-color: #fffde7;
            border: 1px solid #fff59d;
        }
        .segment-call {
            background-color: #ffe8e6;
            border: 1px solid #ffb3ac;
        }
        .segment-comment {
            background-color: #f5f5f5;
            border: 1px solid #e0e0e0;
        }
        .segment-header {
            font-weight: bold;
            margin-bottom: 5px;
        }
        .segment-body {
            padding: 5px;
            background-color: #fff;
            border-radius: 3px;
        }
        .segment-target {
            margin-top: 10px;
            padding: 10px;
            background-color: #ffe8e6;
            border-radius: 3px;
            border-left: 4px solid #ff8a80;
        }
        .component {
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid #bbdefb;
            border-radius: 4px;
            background-color: #e3f2fd;
        }
        .component-title {
            font-weight: bold;
            font-size: 1.1em;
            margin-bottom: 5px;
        }
        .component-description {
            margin-bottom: 10px;
            color: #555;
        }
        .component-segments {
            margin-top: 10px;
        }
        /* Node styles for different types */
        .node-function {
            color: #0d47a1;
            font-weight: bold;
        }
        .node-component {
            color: #00695c;
            font-style: italic;
        }
        .node-segment-code {
            color: #f57f17;
        }
        .node-segment-call {
            color: #d32f2f;
            font-weight: bold;
        }
        .node-segment-comment {
            color: #6d4c41;
        }
        .component-desc {
            color: #666;
            font-size: 0.9em;
            font-style: italic;
            margin-left: 20px;
            display: block;
        }
        .header-nav a {
            color: white;
            text-decoration: none;
            margin-left: 15px;
        }
        .header-nav a:hover {
            text-decoration: underline;
        }
        .code-container {
            font-family: Consolas, Monaco, 'Andale Mono', monospace;
            font-size: 14px;
            counter-reset: line;
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
        }
        .code-line {
            display: flex;
            line-height: 1.5;
            padding: 0 5px;
        }
        .code-line:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }
        .line-number {
            color: #999;
            text-align: right;
            padding-right: 10px;
            min-width: 30px;
            user-select: none;
        }
        /* .line-number::before {
            counter-increment: line;
            content: counter(line);
        } */
        .line-content {
            white-space: pre-wrap;
            padding-left: 5px;
            flex-grow: 1;
        }
        .code-line.strong-highlight {
            border-left: 3px solid #1976d2;
        }
        .view-toggle {
            margin-top: 10px;
            margin-bottom: 10px;
        }
        .view-toggle button {
            background-color: #f1f1f1;
            border: 1px solid #ddd;
            padding: 5px 10px;
            margin-right: 5px;
            cursor: pointer;
            border-radius: 3px;
        }
        .view-toggle button.active {
            background-color: #e0f7fa;
            border-color: #80deea;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
<header>
    <h1>Enhanced Function Segment Tree Viewer</h1>
    <div class="header-nav">
        <a href="/code/">Home</a>
        <a href="/code/tree/{{ repo_hash }}">AST Tree</a>
    </div>
</header>

<div class="container">
    <div class="breadcrumb">
        <a href="/code/">Home</a> &gt; 
        <a href="/code/tree/{{ repo_hash }}">{{ repo_name }}</a> &gt;
        <span>Function Tree</span>
    </div>
    
    <div class="repo-info" data-repo-hash="{{ repo_hash }}">
        <div class="repo-title">{{ repo_name }}</div>
        <div class="repo-url">{{ repo_url }}</div>
    </div>
    
    <div class="tree-container">
        <div class="tree-nav" id="tree">
            <div id="loading-tree" class="loading"></div>
        </div>
        <div class="function-preview" id="function-preview">
            <div class="upper-panel">
                <p>Select a function from the tree to view its details.</p>
                <p>You can explore the function structure by:</p>
                <ul>
                    <li>Clicking on a function to view its details</li>
                    <li>Expanding a function to see its components</li>
                    <li>Expanding components to see their segments</li>
                    <li>Clicking on segments to view their content</li>
                    <li>Expanding call segments to see the target function's components</li>
                </ul>
            </div>
            <div class="lower-panel">
                <p>The complete function code will appear here.</p>
            </div>
        </div>
    </div>
</div>

<script>
    // Keep track of the currently displayed function
    let currentFunctionId = null;

document.addEventListener('DOMContentLoaded', () => {
    const repoHash = document.querySelector('.repo-info').dataset.repoHash;
    loadEntryFunctions(repoHash);
});

async function loadEntryFunctions(repoHash) {
    try {
        // Show loading
        const treeElement = document.getElementById('tree');
        treeElement.innerHTML = '<div id="loading-tree" class="loading"></div>';
        
        // Fetch entry functions
        const response = await fetch(`/code/api/functions/${repoHash}/entries`);
        const functions = await response.json();
        
        // Remove loading
        treeElement.innerHTML = '';
        
        if (functions.length === 0) {
            treeElement.innerHTML = '<p>No entry functions found.</p>';
            return;
        }
        
        // Build the tree
        const rootElement = document.createElement('div');
        rootElement.className = 'node-root';
        treeElement.appendChild(rootElement);
        
        // Add each entry function
        functions.forEach(func => {
            const funcNode = document.createElement('div');
            funcNode.className = 'node';
            funcNode.dataset.id = func.id;
            funcNode.dataset.type = 'function';
            
            const nameElement = document.createElement('span');
            nameElement.className = 'caret node-function';
            nameElement.textContent = func.name;
            nameElement.onclick = function() {
                // Remove active-node class from all nodes
                document.querySelectorAll('.active-node').forEach(node => {
                    node.classList.remove('active-node');
                });
                
                // Add active-node class to this node
                this.classList.add('active-node');
                
                toggleNode(this);
                loadFunctionDetails(repoHash, func.id);
                
                // If expanding and there are no children, load components
                const nested = this.parentElement.querySelector('.nested');
                if (nested && nested.classList.contains('active') && nested.children.length === 0) {
                    loadFunctionComponents(repoHash, func.id, nested);
                }
            };
            
            const childrenElement = document.createElement('div');
            childrenElement.className = 'nested';
            
            funcNode.appendChild(nameElement);
            funcNode.appendChild(childrenElement);
            rootElement.appendChild(funcNode);
        });
    } catch (error) {
        console.error('Error loading entry functions:', error);
        document.getElementById('tree').innerHTML = 
            '<p>Error loading function tree. Please try again later.</p>';
    }
}

function toggleNode(element) {
    element.classList.toggle('caret-down');
    const nested = element.parentElement.querySelector('.nested');
    if (nested) {
        nested.classList.toggle('active');
    }
}

async function loadFunctionComponents(repoHash, functionId, parentElement) {
    try {
        // Show loading
        parentElement.innerHTML = '<div class="loading"></div>';
        
        // Fetch components
        const response = await fetch(`/code/api/functions/${repoHash}/${functionId}/components`);
        const components = await response.json();
        
        // Fetch function details to get segments
        const funcResponse = await fetch(`/code/api/functions/${repoHash}/${functionId}`);
        const functionData = await funcResponse.json();
        
        // Clear loading
        parentElement.innerHTML = '';
        
        if (components.length === 0) {
            // If no components found, display segments directly
            parentElement.innerHTML = '<div class="node">No components found. Showing segments directly:</div>';
            
            // Add segments directly
            if (functionData.segments && functionData.segments.length > 0) {
                loadSegmentsIntoNode(functionData.segments, parentElement, repoHash, functionId);
            } else {
                parentElement.innerHTML += '<div class="node">No segments found</div>';
            }
            return;
        }
        
        // Create a map of component IDs to segments
        const componentSegments = {};
        const unassignedSegments = [];
        
        if (functionData.segments) {
            functionData.segments.forEach(segment => {
                if (segment.func_component_id) {
                    if (!componentSegments[segment.func_component_id]) {
                        componentSegments[segment.func_component_id] = [];
                    }
                    componentSegments[segment.func_component_id].push(segment);
                } else {
                    unassignedSegments.push(segment);
                }
            });
        }
        
        // Add each component
        components.forEach(component => {
            const componentNode = document.createElement('div');
            componentNode.className = 'node';
            componentNode.dataset.id = component.id;
            componentNode.dataset.type = 'component';
            componentNode.dataset.functionId = functionId;
            
            const nameElement = document.createElement('span');
            nameElement.className = 'caret node-component';
            // Use short description as the title instead of "Component N"
            nameElement.textContent = component.short_description || component.name || `Component ${component.index + 1}`;
            
            const segmentsContainer = document.createElement('div');
            segmentsContainer.className = 'nested';
            
            // Add segments for this component
            const segments = componentSegments[component.id] || [];
            
            nameElement.onclick = function() {
                // Remove active-node class from all nodes
                document.querySelectorAll('.active-node').forEach(node => {
                    node.classList.remove('active-node');
                });
                
                // Add active-node class to this node
                this.classList.add('active-node');
                
                toggleNode(this);
                
                // Display component details but keep the same function code
                displayComponentDetails(component, segments, functionId);
                
                // If expanding and there are no children, load segments
                if (segmentsContainer.classList.contains('active') && segmentsContainer.children.length === 0) {
                    if (segments.length > 0) {
                        loadSegmentsIntoNode(segments, segmentsContainer, repoHash, functionId);
                    } else {
                        segmentsContainer.innerHTML = '<div class="node">No segments in this component</div>';
                    }
                }
            };
            
            componentNode.appendChild(nameElement);
            componentNode.appendChild(segmentsContainer);
            parentElement.appendChild(componentNode);
        });
        
        // Add unassigned segments node if there are any
        if (unassignedSegments.length > 0) {
            const unassignedNode = document.createElement('div');
            unassignedNode.className = 'node';
            unassignedNode.dataset.type = 'unassigned';
            unassignedNode.dataset.functionId = functionId;
            
            const unassignedLabel = document.createElement('span');
            unassignedLabel.className = 'caret';
            unassignedLabel.textContent = 'Unassigned Segments';
            
            const unassignedContainer = document.createElement('div');
            unassignedContainer.className = 'nested';
            
            unassignedLabel.onclick = function() {
                // Remove active-node class from all nodes
                document.querySelectorAll('.active-node').forEach(node => {
                    node.classList.remove('active-node');
                });
                
                // Add active-node class to this node
                this.classList.add('active-node');
                
                toggleNode(this);
                
                // Display unassigned segments details without changing the code view
                displayUnassignedSegmentsDetails(unassignedSegments, functionId);
                
                // Load unassigned segments if needed
                if (unassignedContainer.classList.contains('active') && unassignedContainer.children.length === 0) {
                    loadSegmentsIntoNode(unassignedSegments, unassignedContainer, repoHash, functionId);
                }
            };
            
            unassignedNode.appendChild(unassignedLabel);
            unassignedNode.appendChild(unassignedContainer);
            parentElement.appendChild(unassignedNode);
        }
    } catch (error) {
        console.error('Error loading components:', error);
        parentElement.innerHTML = '<div class="node">Error loading function components</div>';
    }
}

function loadSegmentsIntoNode(segments, parentElement, repoHash, parentFunctionId) {
    segments.forEach(segment => {
        const segmentNode = document.createElement('div');
        segmentNode.className = 'node';
        segmentNode.dataset.type = 'segment';
        segmentNode.dataset.segmentType = segment.type;
        segmentNode.dataset.functionId = parentFunctionId;
        
        // For call segments, make them expandable to show the target function
        if (segment.type === 'call' && segment.target_function) {
            const segmentLabel = document.createElement('span');
            segmentLabel.className = 'caret node-segment-call';
            segmentLabel.textContent = `Call: ${segment.target_function.name}() - Line ${segment.lineno}`;
            
            const targetContainer = document.createElement('div');
            targetContainer.className = 'nested';
            
            segmentLabel.onclick = function() {
                // Remove active-node class from all nodes
                document.querySelectorAll('.active-node').forEach(node => {
                    node.classList.remove('active-node');
                });
                
                // Add active-node class to this node
                this.classList.add('active-node');
                
                toggleNode(this);
                
                // For call segments, display the segment in the upper panel and load target function's code
                displaySegmentDetails(segment, segment.target_function.id);
                
                // If expanding and there are no children, load the target function's components
                if (targetContainer.classList.contains('active') && targetContainer.children.length === 0) {
                    // Get the target function
                    const targetFunc = segment.target_function;
                    
                    // Directly load the target function's components into the container
                    loadFunctionComponents(repoHash, targetFunc.id, targetContainer);
                }
            };
            
            segmentNode.appendChild(segmentLabel);
            segmentNode.appendChild(targetContainer);
        } else {
            // For non-call segments (code, comment)
            const segmentLabel = document.createElement('span');
            segmentLabel.className = `node-segment-${segment.type}`;
            
            // Create a preview of the content
            const contentPreview = segment.content.split("\n")[0].substring(0, 30);
            segmentLabel.textContent = `${segment.type.charAt(0).toUpperCase() + segment.type.slice(1)}: ${contentPreview}... (Line ${segment.lineno})`;
            
            // Add click handler to show segment details but keep the same function code
            segmentLabel.onclick = function() {
                // Remove active-node class from all nodes
                document.querySelectorAll('.active-node').forEach(node => {
                    node.classList.remove('active-node');
                });
                
                // Add active-node class to this node
                this.classList.add('active-node');
                
                // Show segment details in the upper panel without changing the function code
                displaySegmentDetails(segment, parentFunctionId);
            };
            
            segmentNode.appendChild(segmentLabel);
        }
        
        parentElement.appendChild(segmentNode);
    });
}

async function loadFunctionCallees(repoHash, functionId, parentElement) {
    try {
        // Show loading
        parentElement.innerHTML = '<div class="loading"></div>';
        
        // Fetch callees
        const response = await fetch(`/code/api/functions/${repoHash}/${functionId}/callees`);
        const callees = await response.json();
        
        // Clear loading
        parentElement.innerHTML = '';
        
        if (callees.length === 0) {
            parentElement.innerHTML = '<div class="node">No function calls</div>';
            return;
        }
        
        // Add each callee
        callees.forEach(callee => {
            const calleeNode = document.createElement('div');
            calleeNode.className = 'node';
            calleeNode.dataset.id = callee.id;
            calleeNode.dataset.type = 'function';
            
            const nameElement = document.createElement('span');
            nameElement.className = 'caret node-function';
            nameElement.textContent = callee.name;
            nameElement.onclick = function() {
                // Remove active-node class from all nodes
                document.querySelectorAll('.active-node').forEach(node => {
                    node.classList.remove('active-node');
                });
                
                // Add active-node class to this node
                this.classList.add('active-node');
                
                toggleNode(this);
                loadFunctionDetails(repoHash, callee.id);
                
                // If expanding and there are no children, load components
                const nested = this.parentElement.querySelector('.nested');
                if (nested && nested.classList.contains('active') && nested.children.length === 0) {
                    loadFunctionComponents(repoHash, callee.id, nested);
                }
            };
            
            const childrenElement = document.createElement('div');
            childrenElement.className = 'nested';
            
            calleeNode.appendChild(nameElement);
            calleeNode.appendChild(childrenElement);
            parentElement.appendChild(calleeNode);
        });
    } catch (error) {
        console.error('Error loading callees:', error);
        parentElement.innerHTML = '<div class="node">Error loading function calls</div>';
    }
}

async function loadFunctionDetails(repoHash, functionId) {
    try {
        // Skip reloading if it's the same function
        if (currentFunctionId === functionId) {
            return;
        }
        
        // Update currently displayed function
        currentFunctionId = functionId;
        
        // Show loading
        const previewElement = document.getElementById('function-preview');
        const upperPanel = previewElement.querySelector('.upper-panel');
        const lowerPanel = previewElement.querySelector('.lower-panel');
        
        upperPanel.innerHTML = '<div class="loading"></div>';
        lowerPanel.innerHTML = '<div class="loading"></div>';
        
        // Fetch function details
        const response = await fetch(`/code/api/functions/${repoHash}/${functionId}`);
        const functionData = await response.json();
        
        // Build the upper panel content (summary)
        let upperPanelContent = `
            <div class="function-details">
                <h2>${functionData.name}</h2>
                <div class="file-path">${functionData.full_name}</div>
                <!-- <div>File: ${functionData.file_path}</div> -->
                <div>Lines: ${functionData.lineno} - ${functionData.end_lineno}</div>
                ${functionData.is_entry ? '<div><strong>Entry Point</strong></div>' : ''}
                ${functionData.class_name ? `<div>Class: ${functionData.class_name}</div>` : ''}
                <div>Module: ${functionData.module_name}</div>
            </div>
        `;
        // Add descriptions if available
        if (functionData.short_description || functionData.input_output_description || functionData.long_description) {
            upperPanelContent += '<div class="function-descriptions">';
            
            if (functionData.short_description) {
                upperPanelContent += `<p><strong>Short Description:</strong> ${functionData.short_description}</p>`;
            }
            
            if (functionData.input_output_description) {
                upperPanelContent += `<p><strong>Input/Output:</strong> ${functionData.input_output_description}</p>`;
            }
            
            if (functionData.long_description) {
                upperPanelContent += `<p><strong>Detailed Description:</strong> ${functionData.long_description}</p>`;
            }
            
            upperPanelContent += '</div>';
        }
        
        // Update upper panel
        upperPanel.innerHTML = upperPanelContent;
        
        // Update lower panel with complete function code
        let lowerPanelContent = await buildFullFunctionCodeView(functionData);
        lowerPanel.innerHTML = `
            <h3>Complete Function Code</h3>
            ${lowerPanelContent}
        `;
    } catch (error) {
        console.error('Error loading function details:', error);
        document.getElementById('function-preview').querySelector('.upper-panel').innerHTML = 
            '<p>Error loading function details. Please try again later.</p>';
        document.getElementById('function-preview').querySelector('.lower-panel').innerHTML = 
            '<p>Error loading function code.</p>';
    }
}

// Helper function to escape HTML
function escapeHTML(str) {
    if (!str) return '';
    return str
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
}
        
        

async function displayComponentDetails(component, segments, functionId) {
    const previewElement = document.getElementById('function-preview');
    const upperPanel = previewElement.querySelector('.upper-panel');
    const lowerPanel = previewElement.querySelector('.lower-panel');
    
    const repoHash = document.querySelector('.repo-info').dataset.repoHash;
    
    // Build the upper panel content (component summary)
    let upperPanelContent = `
        <div class="component">
            <h2>${component.short_description || component.name || `Component ${component.index + 1}`}</h2>
            <p><strong>Lines:</strong> ${component.start_lineno} - ${component.end_lineno}</p>
            ${component.long_description ? `<p><strong>Detailed Description:</strong> ${component.long_description}</p>` : ''}
        </div>
    `;
    
    // Add segments summary
    // if (segments && segments.length > 0) {
    //     upperPanelContent += '<h3>Segments in this Component</h3>';
    //     upperPanelContent += '<div class="segments-summary">';
        
    //     segments.forEach(segment => {
    //         const segmentType = segment.type;
    //         upperPanelContent += `
    //             <div class="segment-summary segment-${segmentType}">
    //                 <div class="segment-header">
    //                     ${segmentType.toUpperCase()} - Line ${segment.lineno}
    //                     ${segment.end_lineno ? ` to ${segment.end_lineno}` : ''}
    //                 </div>
    //             </div>
    //         `;
    //     });
        
    //     upperPanelContent += '</div>';
    // }
    
    // Update upper panel
    upperPanel.innerHTML = upperPanelContent;
    
    // Only update lower panel if the function has changed
    if (currentFunctionId !== functionId) {
        currentFunctionId = functionId;
        lowerPanel.innerHTML = '<div class="loading"></div>';
        
        // Fetch the function details to display the complete code
        try {
            const response = await fetch(`/code/api/functions/${repoHash}/${functionId}`);
            const functionData = await response.json();
            
            // Update lower panel with function code, highlighting the component
            const lowerPanelContent = await buildFullFunctionCodeView(functionData, component);
            lowerPanel.innerHTML = `
                <h3>Complete Function Code</h3>
                ${lowerPanelContent}
            `;
        } catch (error) {
            console.error('Error loading function code for component:', error);
            lowerPanel.innerHTML = '<p>Error loading function code.</p>';
        }
    } else {
        // Same function, just update the view with component highlighting
        const lowerPanelContent = await buildFullFunctionCodeView(null, component);
        if (lowerPanelContent) {
            lowerPanel.innerHTML = `
                <h3>Complete Function Code</h3>
                ${lowerPanelContent}
            `;
        }
    }
}

async function displayUnassignedSegmentsDetails(unassignedSegments, functionId) {
    const previewElement = document.getElementById('function-preview');
    const upperPanel = previewElement.querySelector('.upper-panel');
    
    // Build upper panel content for unassigned segments
    let upperPanelContent = `
        <div class="unassigned-segments-info">
            <h2>Unassigned Segments</h2>
            <p>These segments are not associated with any specific component.</p>
        </div>
    `;
    
    // Add segments summary
    if (unassignedSegments && unassignedSegments.length > 0) {
        upperPanelContent += '<div class="segments-summary">';
        
        unassignedSegments.forEach(segment => {
            const segmentType = segment.type;
            upperPanelContent += `
                <div class="segment-summary segment-${segmentType}">
                    <div class="segment-header">
                        ${segmentType.toUpperCase()} - Line ${segment.lineno}
                        ${segment.end_lineno ? ` to ${segment.end_lineno}` : ''}
                    </div>
                    <div class="segment-preview">
                        ${escapeHTML(segment.content.split('\n')[0])}...
                    </div>
                </div>
            `;
        });
        
        upperPanelContent += '</div>';
    } else {
        upperPanelContent += '<p>No unassigned segments found.</p>';
    }
    
    // Update upper panel
    upperPanel.innerHTML = upperPanelContent;
}

async function displaySegmentDetails(segment, targetFunctionId) {
    const previewElement = document.getElementById('function-preview');
    const upperPanel = previewElement.querySelector('.upper-panel');
    const lowerPanel = previewElement.querySelector('.lower-panel');
    
    const repoHash = document.querySelector('.repo-info').dataset.repoHash;
    const segmentType = segment.type;
    
    // Build the upper panel content (segment summary)
    let upperPanelContent = `
        <div class="segment segment-${segmentType}">
            <h2>${segmentType.toUpperCase()} Segment</h2>
            <div><strong>Lines:</strong> ${segment.lineno}${segment.end_lineno ? ` - ${segment.end_lineno}` : ''}</div>
            <div class="segment-body">
                <pre><code>${escapeHTML(segment.content)}</code></pre>
            </div>
    `;
    
    // For call segments, add target info
    if (segmentType === 'call' && segment.target_function) {
        const target = segment.target_function;
        upperPanelContent += `
            <div class="segment-target">
                <div><strong>Name:</strong> ${target.name} (${target.full_name})</div>
                <div><strong>Lines:</strong> ${target.lineno} - ${target.end_lineno}</div>
            </div>
        `;
    }
    
    upperPanelContent += '</div>'; // Close segment div
    
    // Update upper panel
    upperPanel.innerHTML = upperPanelContent;
    
    // Determine if we need to update the lower panel (code view)
    // For call segments, show the target function's code
    // For other segments, keep showing the parent function or update if needed
    if (segmentType === 'call' && segment.target_function && targetFunctionId !== currentFunctionId) {
        // Update current function ID
        currentFunctionId = targetFunctionId;
        
        // Show loading in lower panel
        lowerPanel.innerHTML = '<div class="loading"></div>';
        
        try {
            // Fetch the target function details
            const response = await fetch(`/code/api/functions/${repoHash}/${targetFunctionId}`);
            const functionData = await response.json();
            
            // Build the lower panel content
            const lowerPanelContent = await buildFullFunctionCodeView(functionData);
            
            // Update lower panel
            lowerPanel.innerHTML = `
                <h3>Target Function: ${functionData.name}</h3>
                ${lowerPanelContent}
            `;
        } catch (error) {
            console.error('Error loading target function:', error);
            lowerPanel.innerHTML = '<p>Error loading target function code.</p>';
        }
    } else if (targetFunctionId !== currentFunctionId) {
        // Not a call segment or target function is already displayed
        // Update current function ID
        currentFunctionId = targetFunctionId;
        
        // Show loading in lower panel
        lowerPanel.innerHTML = '<div class="loading"></div>';
        
        try {
            // Fetch the function details
            const response = await fetch(`/code/api/functions/${repoHash}/${targetFunctionId}`);
            const functionData = await response.json();
            
            // Build the lower panel content, highlighting the segment
            const lowerPanelContent = await buildFullFunctionCodeView(functionData, null, segment);
            
            // Update lower panel
            lowerPanel.innerHTML = `
                <h3>Complete Function Code</h3>
                ${lowerPanelContent}
            `;
        } catch (error) {
            console.error('Error loading function for segment:', error);
            lowerPanel.innerHTML = '<p>Error loading function code.</p>';
        }
    } else {
        // Same function, just update the highlighting in the existing code view
        try {
            // Fetch the function details if needed
            const response = await fetch(`/code/api/functions/${repoHash}/${targetFunctionId}`);
            const functionData = await response.json();
            
            // Build the lower panel content, highlighting the segment
            const lowerPanelContent = await buildFullFunctionCodeView(functionData, null, segment);
            
            // Update lower panel
            lowerPanel.innerHTML = `
                <h3>Complete Function Code</h3>
                ${lowerPanelContent}
            `;
        } catch (error) {
            console.error('Error updating segment highlighting:', error);
        }
    }
}

// Helper function to build a complete function code view with highlighting
// Helper function to build a complete function code view with highlighting
async function buildFullFunctionCodeView(functionData, highlightComponent = null, highlightSegment = null) {
    // If functionData is null but we have a current function ID, fetch the function data
    if (!functionData && currentFunctionId) {
        try {
            const repoHash = document.querySelector('.repo-info').dataset.repoHash;
            const response = await fetch(`/code/api/functions/${repoHash}/${currentFunctionId}`);
            functionData = await response.json();
        } catch (error) {
            console.error('Error fetching current function data:', error);
            return '<p>Error loading function code.</p>';
        }
    }
    
    // If we still don't have function data, return an error message
    if (!functionData) {
        return '<p>No function data available.</p>';
    }
    
    try {
        // Use the file_path and line numbers to get the complete function code
        const filePath = functionData.file_path;
        const startLine = functionData.lineno;
        const endLine = functionData.end_lineno;
        
        // Fetch the file content using an API endpoint
        let fileLines = [];
        let useSegmentsFallback = true;
        
        // Try to get file content from repository if we have required info
        if (filePath && startLine && endLine) {
            try {
                const repoHash = document.querySelector('.repo-info').dataset.repoHash;
                const response = await fetch(`/code/api/file?path=${encodeURIComponent(filePath)}&repo_hash=${repoHash}&line_start=${startLine}&line_end=${endLine}`);
                
                if (response.ok) {
                    const fileContent = await response.text();
                    fileLines = fileContent.split('\n');
                    useSegmentsFallback = false;
                } else {
                    console.warn('Error fetching file content, fallback to segments');
                }
            } catch (fileError) {
                console.warn('Error reading file directly, falling back to segments:', fileError);
                // Continue with segments fallback
            }
        }
        
        // Fallback: reconstruct from segments
        if (useSegmentsFallback) {
            // Sort segments by line number to ensure correct order
            const sortedSegments = [...functionData.segments].sort((a, b) => a.lineno - b.lineno);
            
            // Create an array to hold all lines of the function
            const totalLines = endLine - startLine + 1;
            fileLines = Array(totalLines).fill('');
            
            // Fill in content from segments
            for (const segment of sortedSegments) {
                const segmentContent = segment.content.split('\n');
                const relStartLine = segment.lineno;
                
                for (let i = 0; i < segmentContent.length; i++) {
                    const fileLineIndex = relStartLine - 1 + i;
                    if (fileLineIndex >= 0 && fileLineIndex < totalLines) {
                        fileLines[fileLineIndex] = segmentContent[i];
                    }
                }
            }
        }
        
        // Prepare the code with syntax highlighting for segments
        let codeLines = [];
        
        // Get components for the function
        let components = [];
        try {
            const repoHash = document.querySelector('.repo-info').dataset.repoHash;
            const compResponse = await fetch(`/code/api/functions/${repoHash}/${functionData.id}/components`);
            if (compResponse.ok) {
                components = await compResponse.json();
            }
        } catch (error) {
            console.warn('Error fetching components:', error);
        }
        
        // Sort components by start line
        components.sort((a, b) => a.start_lineno - b.start_lineno);
        
        // Use different background colors for different elements
        const componentColors = [
            'rgba(187, 222, 251, 0.15)',  // Light blue (very faint)
            'rgba(200, 230, 201, 0.15)',  // Light green (very faint)
            'rgba(255, 236, 179, 0.15)'   // Light amber (very faint)
        ];
        
        const segmentColors = {
            'code': 'rgba(255, 253, 231, 0.2)',    // Light yellow (faint)
            'call': 'rgba(255, 232, 230, 0.2)',    // Light red (faint)
            'comment': 'rgba(245, 245, 245, 0.2)'  // Light gray (faint)
        };
        
        const highlightedComponentColor = 'rgba(187, 222, 251, 0.5)';  // Blue (stronger)
        
        const highlightedSegmentColors = {
            'code': 'rgba(255, 253, 231, 0.7)',    // Yellow (stronger)
            'call': 'rgba(255, 232, 230, 0.7)',    // Red (stronger)
            'comment': 'rgba(245, 245, 245, 0.7)'  // Gray (stronger)
        };
        
        // Function to determine if a line belongs to a component
        function lineInComponent(absLine, component) {
            return absLine >= component.start_lineno && absLine <= component.end_lineno;
        }
        
        // Function to determine if a line belongs to a segment
        function lineInSegment(relLine, segment) {
            return relLine >= segment.lineno && 
                   (segment.end_lineno ? relLine <= segment.end_lineno : relLine === segment.lineno);
        }
        
        // Function to get the component index for coloring
        function getComponentIndex(component, components) {
            const index = components.findIndex(c => c.id === component.id);
            return index >= 0 ? index % componentColors.length : -1;
        }
        
        // Build code lines with appropriate highlighting
        for (let i = 0; i < fileLines.length; i++) {
            const relLine = i + 1;  // Relative line number (1-based)
            const absLine = functionData.lineno + i;  // Absolute line number
            const lineContent = fileLines[i] || '';
            
            // Find the component that contains this line
            const containingComponent = components.find(comp => lineInComponent(absLine, comp));
            
            // Find the segment that contains this line
            const segment = functionData.segments.find(seg => lineInSegment(relLine, seg));
            
            // Determine the background color and highlighting
            let backgroundColor = 'transparent';
            let borderLeft = '';
            let strongHighlight = false;
            
            // Base component highlighting (always show component regions with faint colors)
            if (containingComponent) {
                const colorIndex = getComponentIndex(containingComponent, components);
                backgroundColor = componentColors[colorIndex >= 0 ? colorIndex : 0];
            }
            
            // Enhanced component highlighting when a specific component is selected
            if (highlightComponent && containingComponent && highlightComponent.id === containingComponent.id) {
                backgroundColor = highlightedComponentColor;
                borderLeft = '3px solid #1976d2';
                strongHighlight = true;
            }
            
            // Segment highlighting (overrides component highlighting)
            if (segment) {
                // Apply stronger highlight if this segment is specifically selected
                if (highlightSegment && segment.id === highlightSegment.id) {
                    backgroundColor = highlightedSegmentColors[segment.type];
                    borderLeft = '3px solid #f57c00';
                    strongHighlight = true;
                }
                // Otherwise, if we're viewing a call segment and not on a component view,
                // just add a light highlight to all segments
                else if (!highlightComponent) {
                    // Mix the segment color with existing background
                    const segmentColor = segmentColors[segment.type];
                    if (backgroundColor === 'transparent') {
                        backgroundColor = segmentColor;
                    }
                    // Otherwise, the component background will remain
                }
            }
            
            // Generate the HTML for this line
            codeLines.push(`
                <div class="code-line ${strongHighlight ? 'strong-highlight' : ''}" 
                     style="background-color: ${backgroundColor}; ${borderLeft ? 'border-left: ' + borderLeft + ';' : ''}">
                    <span class="line-number">${relLine}</span>
                    <span class="line-content">${escapeHTML(lineContent)}</span>
                </div>
            `);
        }
        
        // Return the complete code view
        return `
            <div class="function-code-view">
                <div class="code-container">
                    ${codeLines.join('')}
                </div>
            </div>
        `;
    } catch (error) {
        console.error('Error building function code view:', error);
        return `<p>Error displaying function code: ${error.message}</p>`;
    }
}


</script>
<!-- <script src="/code/static/js/tree.js"></script> -->
</body>
</html>