diff --git a/app/remote_tree_builder.py b/app/remote_tree_builder.py
index d0f5b3370c..abf2ec930f 100644
--- a/app/remote_tree_builder.py
+++ b/app/remote_tree_builder.py
@@ -11,6 +11,7 @@ from dulwich.repo import Repo
 import tempfile
 import shutil
 from sqlalchemy.ext.declarative import declarative_base
+import logging
 Base = declarative_base()
 
 # Import custom modules for database models and AST parsing
@@ -24,7 +25,9 @@ except ImportError:
     
     
     
-    class Repository(Base):
+    # Configure logging
+    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
+        class Repository(Base):
         __tablename__ = 'repositories'
         id = Column(String(64), primary_key=True)
         url = Column(String(512), unique=True)
@@ -41,6 +44,9 @@ except ImportError:
         end_lineno = Column(Integer)
         is_entry = Column(Boolean, default=False)
         class_name = Column(String(128), nullable=True)
+        short_description = Column(String(255), nullable=True)
+        input_output_description = Column(Text, nullable=True)
+        long_description = Column(Text, nullable=True)
         module_name = Column(String(256))
     
     class Segment(Base):
@@ -54,13 +60,26 @@ except ImportError:
         index = Column(Integer)
         target_id = Column(String(128), ForeignKey('functions.id', ondelete='SET NULL'), nullable=True)
         segment_data = Column(JSON, nullable=True)
+        func_component_id = Column(String(256), ForeignKey('func_components.id', ondelete='SET NULL'), nullable=True)
     
-    class FunctionCall(Base):
+    class FuncComponent(Base):
+        __tablename__ = 'func_components'
+        id = Column(String(256), primary_key=True)
+        function_id = Column(String(128), ForeignKey('functions.id', ondelete='CASCADE'))
+        short_description = Column(String(255))
+        long_description = Column(Text)
+        start_lineno = Column(Integer)
+        end_lineno = Column(Integer)
+        index = Column(Integer)
+        component_data = Column(JSON, nullable=True)
+        
+        class FunctionCall(Base):
         __tablename__ = 'function_calls'
         caller_id = Column(String(128), ForeignKey('functions.id', ondelete='CASCADE'), primary_key=True)
         callee_id = Column(String(128), ForeignKey('functions.id', ondelete='CASCADE'), primary_key=True)
         call_count = Column(Integer, default=1)
         metadata = Column(JSON, nullable=True)
+    
 sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
 try:
     from app.utils.ast_parser import scan_project, find_entry_points, build_tree_from_function, print_tree, print_function_info
@@ -68,7 +87,26 @@ except ImportError:
     # For standalone running, import from the current directory
     from utils.ast_parser import scan_project, find_entry_points, build_tree_from_function, print_tree, print_function_info
 
-def store_registry_in_database(registry, repo_url, repo_hash, entry_points, session):
+# Try to import LLM function analyzer
+try:
+    from app.utils.llm_function_analyzer import set_api_key, analyze_function
+    has_llm_analyzer = True
+except ImportError:
+    # LLM analyzer not available
+    has_llm_analyzer = False
+    logging.warning("LLM function analyzer not available. Running without LLM analysis.")
+
+def extract_function_source(file_path, start_line, end_line):
+    """Extract the source code for a function from a file"""
+    try:
+        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
+            lines = f.readlines()
+            return ''.join(lines[start_line-1:end_line])
+    except Exception as e:
+        logging.error(f"Error extracting function source from {file_path}: {str(e)}")
+        return ""
+
+def store_registry_in_database(registry, repo_url, repo_hash, entry_points, session, use_llm=False, api_key=None):
     """
     Store the function registry in the database
     
@@ -77,8 +115,14 @@ def store_registry_in_database(registry, repo_url, repo_hash, entry_points, sess
         repo_url: Repository URL
         repo_hash: Repository hash
         entry_points: List of entry function IDs
+        use_llm: Whether to use LLM analysis for functions
+        api_key: API key for the LLM service (if use_llm is True)
         session: SQLAlchemy session
     
+    Returns:
+        Repository object
+    """
+    # Set up LLM if requested
     Returns:
         Repository object
     """
@@ -103,6 +147,13 @@ def store_registry_in_database(registry, repo_url, repo_hash, entry_points, sess
     # Commit to ensure repository exists before adding functions
     session.commit()
     
+    # Set up LLM if requested
+    if use_llm and has_llm_analyzer:
+        if api_key:
+            set_api_key(api_key)
+        elif not api_key:
+            logging.warning("No API key provided for LLM analysis. Some features may not work.")
+    
     # Store functions
     function_count = 0
     for func_id, func_info in registry.functions.items():
@@ -139,6 +190,59 @@ def store_registry_in_database(registry, repo_url, repo_hash, entry_points, sess
     # Commit all functions
     session.commit()
     
+    # Second pass: LLM analysis for functions if requested
+    if use_llm and has_llm_analyzer:
+        logging.info("Running LLM analysis for functions...")
+        analysis_count = 0
+        
+        for func_id, func_info in registry.functions.items():
+            db_func_id = f"{repo_hash}:{func_id}"
+            
+            # Skip functions without a proper file path or line numbers
+            if not func_info.get('file_path') or not os.path.exists(func_info.get('file_path', '')):
+                continue
+                
+            # Extract function source
+            func_source = extract_function_source(
+                func_info['file_path'],
+                func_info['lineno'],
+                func_info['end_lineno']
+            )
+            
+            if not func_source:
+                continue
+                
+            # Run LLM analysis
+            try:
+                logging.info(f"Analyzing function: {func_info['full_name']}")
+                analysis = analyze_function(func_source, func_info['name'], func_info['file_path'])
+                
+                # Update function record with analysis
+                func_record = session.query(Function).get(db_func_id)
+                if func_record:
+                    func_record.short_description = analysis['short_description']
+                    func_record.input_output_description = analysis['input_output_description'] 
+                    func_record.long_description = analysis['long_description']
+                    
+                    # Create components
+                    for idx, component in enumerate(analysis['components']):
+                        component_id = f"{db_func_id}:component_{idx}"
+                        
+                        # Convert relative line numbers to absolute
+                        abs_start_line = func_info['lineno'] + component['start_line'] - 1
+                        abs_end_line = func_info['lineno'] + component['end_line'] - 1
+                        
+                        component_record = FuncComponent(
+                            id=component_id,
+                            function_id=db_func_id,
+                            short_description=component['short_description'],
+                            long_description=component['long_description'],
+                            start_lineno=abs_start_line,
+                            end_lineno=abs_end_line,
+                            index=idx
+                        )
+                        session.add(component_record)
+                        
+                    analysis_count += 1
+                    
+                # Commit periodically
+                if analysis_count % 10 == 0:
+                    session.commit()
+                    logging.info(f"Analyzed {analysis_count} functions")
+                    
+            except Exception as e:
+                logging.error(f"Error analyzing function {func_info['full_name']}: {str(e)}")
+                continue
+                
+        # Commit remaining function analyses
+        session.commit()
+        logging.info(f"Completed LLM analysis for {analysis_count} functions")
+    
     # Store segments
     segment_count = 0
     for func_id, func_info in registry.functions.items():
@@ -172,6 +276,27 @@ def store_registry_in_database(registry, repo_url, repo_hash, entry_points, sess
     # Commit all segments
     session.commit()
     
+    # Third pass: Assign segments to components if LLM was used
+    if use_llm and has_llm_analyzer:
+        logging.info("Assigning segments to components...")
+        
+        for func_id, func_info in registry.functions.items():
+            db_func_id = f"{repo_hash}:{func_id}"
+            
+            # Get all components for this function
+            components = session.query(FuncComponent).filter_by(function_id=db_func_id).order_by(FuncComponent.index).all()
+            if not components:
+                continue
+                
+            # Get all segments for this function
+            segments = session.query(Segment).filter_by(function_id=db_func_id).all()
+            
+            # Assign each segment to a component based on line numbers
+            for segment in segments:
+                for component in components:
+                    if segment.lineno >= component.start_lineno and (segment.end_lineno or segment.lineno) <= component.end_lineno:
+                        segment.func_component_id = component.id
+                        break
+        
+        # Commit segment assignments
+        session.commit()
+        logging.info("Completed assigning segments to components")
+    
     # Store function calls (many-to-many relationships)
     for func_id, func_info in registry.functions.items():
         db_func_id = f"{repo_hash}:{func_id}"
@@ -206,7 +331,7 @@ def clone_repository(repo_url, cache_dir='/tmp/repos'):
     return repo, repo_path, repo_hash
 
 
-def build_and_store_code_tree(repo_url, entry_points, db_uri, verbose=False):
+def build_and_store_code_tree(repo_url, entry_points, db_uri, use_llm=False, api_key=None, verbose=False):
     """
     Main function to build a code tree and store it in the database
     
@@ -267,7 +392,8 @@ def build_and_store_code_tree(repo_url, entry_points, db_uri, verbose=False):
             if verbose:
                 print("Storing data in database...")
             
-            repo_record = store_registry_in_database(
                registry, repo_url, repo_hash, entry_point_ids, session, 
                use_llm=use_llm, api_key=api_key
            )
            
            if verbose:
                print(f"Successfully stored data for repository {repo_url}")
                print(f"Repository hash: {repo_hash}")
            
            return repo_hash
            
        except Exception as e:
            session.rollback()
            print(f"Error storing data: {str(e)}")
            raise
        finally:
            session.close()
    
    finally:
        # Clean up
        shutil.rmtree(temp_dir)


def query_and_print_tree(repo_hash, entry_id, db_uri, max_level=2, verbose=False):
    """
    Query the database and print a function tree
    
    Args:
        repo_hash: Repository hash
        entry_id: Entry function ID
        db_uri: Database URI
        max_level: Maximum level to print
        verbose: Whether to print verbose output
    """
    # Connect to database
    engine = create_engine(db_uri)
    Session = sessionmaker(bind=engine)
    session = Session()
    
    try:
        # Get repository
        repo = session.query(Repository).filter_by(id=repo_hash).first()
        if not repo:
            print(f"Repository with hash {repo_hash} not found")
            return
        
        # Get entry function
        function = session.query(Function).filter_by(id=entry_id).first()
        if not function:
            print(f"Function with ID {entry_id} not found")
            return
        
        print("=" * 60)
        print(f"FUNCTION TREE: {function.full_name}")
        print(f"Repository: {repo.url}")
        print("=" * 60)
        
        # Print LLM analysis if available
        if function.short_description or function.long_description:
            print("\nLLM ANALYSIS:")
            if function.short_description:
                print(f"Short Description: {function.short_description}")
            if function.input_output_description:
                print(f"Input/Output: {function.input_output_description}")
            if function.long_description:
                print(f"Description: {function.long_description}")
            print("-" * 60)
        
        # Get components for this function
        components = session.query(FuncComponent).filter_by(function_id=entry_id).order_by(FuncComponent.index).all()
        
        if components:
            print("\nFUNCTION COMPONENTS:")
            for component in components:
                print(f"\n  Component {component.index+1}: Lines {component.start_lineno}-{component.end_lineno}")
                print(f"  Short Description: {component.short_description}")
                print(f"  Description: {component.long_description}")
                
                # Get segments assigned to this component
                segments = session.query(Segment).filter_by(func_component_id=component.id).all()
                if segments and verbose:
                    print("\n  Segments:")
                    for segment in segments:
                        print(f"    - [{segment.type.upper()}] Line {segment.lineno}")
                        
                        # For call segments, show target
                        if segment.type == 'call' and segment.target_id:
                            target = session.query(Function).filter_by(id=segment.target_id).first()
                            if target:
                                print(f"      Calls: {target.full_name}")
            print("-" * 60)
        
        # Get segments for this function
        segments = session.query(Segment).filter_by(function_id=entry_id).order_by(Segment.index).all()
        
        # Print function details
        print(f"Function: {function.name}")
        print(f"Full name: {function.full_name}")
        print(f"File: {function.file_path}")
        print(f"Lines: {function.lineno} - {function.end_lineno}")
        
        # Print segments if level >= 1
        if max_level >= 1:
            print("\nSEGMENTS:")
            for segment in segments:
                print(f"\n  [{segment.type.upper()}] Line {segment.lineno}")
                
                # For call segments, show target
                if segment.type == 'call' and segment.target_id:
                    target = session.query(Function).filter_by(id=segment.target_id).first()
                    if target:
                        print(f"  Calls: {target.full_name}")
                
                # Print content
                content_lines = segment.content.split('\n')
                for i, line in enumerate(content_lines[:10]):  # Limit to 10 lines
                    print(f"    {i+1:3d} | {line}")
                
                if len(content_lines) > 10:
                    print(f"    ... ({len(content_lines)-10} more lines)")
                
                # For call segments with level >= 2, show called function
                if segment.type == 'call' and segment.target_id and max_level >= 2:
                    target = session.query(Function).filter_by(id=segment.target_id).first()
                    if target:
                        # Get segments for the target function
                        target_segments = session.query(Segment).filter_by(
                            function_id=segment.target_id
                        ).order_by(Segment.index).all()
                        
                        print(f"\n  CALLED FUNCTION: {target.name}")
                        print(f"  Full name: {target.full_name}")
                        print(f"  File: {target.file_path}")
                        print(f"  Lines: {target.lineno} - {target.end_lineno}")
                        
                        # Print target segments if level >= 3
                        if max_level >= 3:
                            print("\n  TARGET SEGMENTS:")
                            for target_segment in target_segments:
                                print(f"\n    [{target_segment.type.upper()}] Line {target_segment.lineno}")
                                
                                # Limit content
                                target_content_lines = target_segment.content.split('\n')
                                for i, line in enumerate(target_content_lines[:5]):  # More limited
                                    print(f"      {i+1:3d} | {line}")
                                
                                if len(target_content_lines) > 5:
                                    print(f"      ... ({len(target_content_lines)-5} more lines)")
    finally:
        session.close()


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Build and store a code tree")
    
    # Command subparsers
    subparsers = parser.add_subparsers(dest="command", help="Command to run")
    
    # Build command
    build_parser = subparsers.add_parser("build", help="Build and store a code tree")
    build_parser.add_argument("repo_url", help="Repository URL")
    build_parser.add_argument("entry_points", nargs="+", help="Entry point files (file.py[:function_name])")
    build_parser.add_argument("--db-uri", 
                            default="postgresql://codeuser:<code_password>@localhost:5432/code",
                            help="Database URI")
    build_parser.add_argument("--use-llm", action="store_true", help="Use LLM for function analysis")
    build_parser.add_argument("--api-key", help="API key for LLM service")
    build_parser.add_argument("-v", "--verbose", action="store_true", help="Verbose output")
    
    # View command
    view_parser = subparsers.add_parser("view", help="View a function tree")
    view_parser.add_argument("repo_hash", help="Repository hash")
    view_parser.add_argument("function_id", help="Function ID")
    view_parser.add_argument("--level", type=int, default=2, help="Maximum level to print")
    view_parser.add_argument("--db-uri",
                           default="postgresql://codeuser:<code_password>@localhost:5432/code",
                           help="Database URI")
    view_parser.add_argument("-v", "--verbose", action="store_true", help="Verbose output")
    
    args = parser.parse_args()
    
    if args.command == "build":
        repo_hash = build_and_store_code_tree(
            args.repo_url, args.entry_points, args.db_uri, 
            use_llm=args.use_llm, api_key=args.api_key, verbose=args.verbose
        )
        
        if repo_hash:
            print(f"Successfully built and stored code tree for {args.repo_url}")
            print(f"Repository hash: {repo_hash}")
    
    elif args.command == "view":
        query_and_print_tree(
            args.repo_hash, args.function_id, args.db_uri, args.level, args.verbose
        )
    
    else:
        parser.print_help()